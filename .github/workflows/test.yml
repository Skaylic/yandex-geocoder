name: Python CI

on:
  # Триггеры запуска
  push:
    branches: [ main, master, develop ]
    paths:
      - '**/*.py'
      - 'requirements.txt'
      - '.github/workflows/test.yml'
  pull_request:
    branches: [ main, master, develop ]
    paths:
      - '**/*.py'
      - 'requirements.txt'
      - '.github/workflows/test.yml'

  # Разрешить запуск вручную из интерфейса GitHub
  workflow_dispatch:

# Переменные окружения
env:
  PYTHON_VERSION: '3.9'  # Указываем версию Python
  REQUIREMENTS_FILE: 'requirements.txt'  # Файл с зависимостями
jobs:
  test:
    # Название задачи
    name: Run Tests with Python ${{ matrix.python-version }}

    # ОС для запуска
    runs-on: ubuntu-latest

    # Матрица для тестирования на разных версиях Python
    strategy:
      matrix:
        python-version: ['3.8', '3.9', '3.10', '3.11', '3.13']

    # Шаги выполнения
    steps:
      # 1. Проверка кода
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Полная история для coverage

      # 2. Настройка Python
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'  # Кэширование pip для ускорения

      # 3. Установка зависимостей
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f "${{ env.REQUIREMENTS_FILE }}" ]; then
            pip install -r ${{ env.REQUIREMENTS_FILE }}
          else
            pip install requests python-dotenv pandas openpyxl ratelimit pytest
          fi
          # Для coverage и дополнительных инструментов
          pip install pytest-cov pytest-xdist

      # 4. Проверка стиля кода (опционально)
      - name: Lint with flake8
        run: |
          pip install flake8
          # Остановить сборку если есть ошибки стиля
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          # Вывод предупреждений
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

      # 5. Запуск тестов
      - name: Test with pytest
        env:
          # Тестовый API ключ для CI (можно создать секрет в GitHub)
          YANDEX_API_KEY: ${{ secrets.YANDEX_API_KEY_TEST }}
        run: |
          python -m pytest test_geocoder.py \
            --verbose \
            --cov=geocoder_app \
            --cov-report=xml \
            --cov-report=html \
            --cov-report=term-missing \
            --junitxml=junit/test-results-${{ matrix.python-version }}.xml \
            --tb=short

      # 6. Сохранение отчетов
      - name: Upload test results
        if: always()  # Всегда выполняем, даже если тесты упали
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.python-version }}
          path: |
            junit/test-results-${{ matrix.python-version }}.xml
            coverage.xml
            htmlcov/
          retention-days: 7

      # 7. Отправка отчета о покрытии в Codecov (опционально)
      - name: Upload coverage to Codecov
        if: success()
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.xml
          fail_ci_if_error: false

      # 8. Создание сводки тестов
      - name: Generate test summary
        if: always()
        run: |
          echo "### Тестирование YandexGeocoder" >> $GITHUB_STEP_SUMMARY
          echo "**Python версия:** ${{ matrix.python-version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Статус:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Метрики:" >> $GITHUB_STEP_SUMMARY
          
          # Извлекаем метрики из coverage.xml
          if [ -f "coverage.xml" ]; then
            echo "- Отчет о покрытии доступен как артефакт" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Проверяем результаты тестов
          if [ -f "junit/test-results-${{ matrix.python-version }}.xml" ]; then
            echo "- Результаты тестов в формате JUnit XML" >> $GITHUB_STEP_SUMMARY
          fi

  # Дополнительная задача для проверки сборки
  build:
    name: Build and verify
    runs-on: ubuntu-latest
    needs: test  # Зависит от успешного прохождения тестов

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'

      - name: Verify imports
        run: |
          python -c "
          try:
              import geocoder_app
              import pandas
              import requests
              print('Все импорты успешны ✅')
          except ImportError as e:
              print(f'Ошибка импорта: {e}')
              exit(1)
          "

      - name: Check syntax
        run: |
          python -m py_compile geocoder_app.py
          python -m py_compile test_geocoder.py
          echo 'Синтаксис корректен ✅'

  # Задача для нотификаций (опционально)
  notify:
    name: Notifications
    runs-on: ubuntu-latest
    needs: [test, build]
    if: always()  # Всегда выполняем, даже если предыдущие задачи упали

    steps:
      - name: Check workflow status
        id: check
        run: |
          if [[ "${{ needs.test.result }}" == "success" && "${{ needs.build.result }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=✅ Все тесты пройдены успешно!" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=❌ Обнаружены проблемы в тестах или сборке" >> $GITHUB_OUTPUT
          fi

      # Отправка в Slack (нужно настроить секреты)
      - name: Slack Notification
        if: failure()
        uses: slackapi/slack-github-action@v1.25.0
        with:
          channel-id: ${{ secrets.SLACK_CHANNEL_ID }}
          slack-message: "Workflow ${{ github.workflow }} завершился со статусом: ${{ steps.check.outputs.status }}\nJob: ${{ github.job }}\nCommit: ${{ github.event.head_commit.message }}\n${{ steps.check.outputs.message }}"
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}